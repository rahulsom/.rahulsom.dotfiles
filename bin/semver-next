#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#     "semver",
# ]
# ///

"""Suggest next semantic version based on git tags.
Usage: semver-next [major|minor|patch] [rc] [-v|--verbose]
"""

import argparse
import re
import subprocess
import sys

import semver


def get_git_tags_sorted():
    """Return git tags sorted by version descending."""
    result = subprocess.run(
        ["git", "tag", "--sort=-version:refname"],
        capture_output=True,
        text=True,
        check=True,
    )
    return [t.strip() for t in result.stdout.strip().splitlines() if t.strip()]


def is_strict_release(tag: str) -> bool:
    """True if tag is a strict x.y.z release (no prerelease suffix)."""
    v = tag.lstrip("v")
    return bool(re.match(r"^\d+\.\d+\.\d+$", v))


def parse_version_from_tag(tag: str) -> semver.VersionInfo | None:
    """Parse tag (with optional 'v' prefix) into VersionInfo, or None if invalid."""
    v = tag.lstrip("v")
    try:
        return semver.VersionInfo.parse(v)
    except ValueError:
        return None


RC_PRERELEASE_RE = re.compile(r"^rc\.(\d+)$", re.IGNORECASE)


def next_rc_number(version_info: semver.VersionInfo, target_base: semver.VersionInfo) -> int:
    """If version_info is target_base-rc.N, return N+1; else return 1."""
    if version_info.major != target_base.major or version_info.minor != target_base.minor or version_info.patch != target_base.patch:
        return 1
    if not version_info.prerelease:
        return 1
    m = RC_PRERELEASE_RE.match(version_info.prerelease)
    if not m:
        return 1
    return int(m.group(1)) + 1


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Suggest next semantic version based on git tags",
        epilog=(
            "  major: Increment major version (breaking changes)\n"
            "  minor: Increment minor version (new features)\n"
            "  patch: Increment patch version (bug fixes)\n"
            "  rc: Next release candidate (e.g. minor rc â†’ v1.3.0-rc.1)\n"
            "  -v, --verbose: Show current version info"
        ),
    )
    parser.add_argument(
        "bump",
        nargs="?",
        default="patch",
        choices=["major", "minor", "patch"],
        help="Version bump type (default: patch)",
    )
    parser.add_argument(
        "rc",
        nargs="?",
        choices=["rc"],
        help="If given, output next release candidate (e.g. 1.3.0-rc.1)",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Show current version info",
    )
    args = parser.parse_args()

    tags = get_git_tags_sorted()

    # When asking for rc, use latest tag overall so we see existing RCs (e.g. 1.3.0-rc.1)
    if args.rc == "rc" and tags:
        latest_tag = tags[0]
    else:
        # Prefer latest strict release (x.y.z only, no -rc.N)
        latest_tag = None
        for t in tags:
            if is_strict_release(t):
                latest_tag = t
                break
        if latest_tag is None and tags:
            latest_tag = tags[0]

    if latest_tag is None:
        if args.verbose:
            print("No tags found. Suggesting initial version: v1.0.0", file=sys.stderr)
        print("v1.0.0")
        return

    version_info = parse_version_from_tag(latest_tag)
    if version_info is None:
        print(
            f"Error: Latest tag '{latest_tag}' doesn't follow semantic versioning format",
            file=sys.stderr,
        )
        sys.exit(1)

    # Use base version (strip prerelease/build for bumping)
    base = semver.VersionInfo(
        version_info.major,
        version_info.minor,
        version_info.patch,
    )

    bump = args.bump
    if bump == "major":
        next_version = base.bump_major()
    elif bump == "minor":
        next_version = base.bump_minor()
    else:
        next_version = base.bump_patch()

    if args.rc == "rc":
        # If latest tag is already an rc (e.g. 1.3.0-rc.1), next is same base + rc.(N+1)
        if version_info.prerelease and RC_PRERELEASE_RE.match(version_info.prerelease):
            target_base = semver.VersionInfo(
                version_info.major, version_info.minor, version_info.patch
            )
            rc_num = next_rc_number(version_info, target_base)
        else:
            target_base = next_version
            rc_num = 1
        next_version = semver.VersionInfo(
            target_base.major,
            target_base.minor,
            target_base.patch,
            prerelease=f"rc.{rc_num}",
        )

    new_version = f"v{next_version}"

    if args.verbose:
        print(f"Current version: {latest_tag}", file=sys.stderr)
        print(f"Suggested next version: {new_version}", file=sys.stderr)

    print(new_version)


if __name__ == "__main__":
    main()
