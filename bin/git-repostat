#!/usr/bin/ruby
#

class Colorizator
  COLOURS    = {default:    '38', black: '30', red: '31', green: '32', brown: '33', blue: '34', purple: '35',
                cyan:       '36', gray: '37', dark_gray: '1;30', light_red: '1;31', light_green: '1;32', yellow: '1;33',
                light_blue: '1;34', light_purple: '1;35', light_cyan: '1;36', white: '1;37'}.freeze
  BG_COLOURS = {default: '0', black: '40', red: '41', green: '42', brown: '43', blue: '44',
                purple:  '45', cyan: '46', gray: '47', dark_gray: '100', light_red: '101', light_green: '102',
                yellow:  '103', light_blue: '104', light_purple: '105', light_cyan: '106', white: '107'}.freeze

  FONT_OPTIONS = {bold: '1', dim: '2', italic: '3', underline: '4', reverse: '7', hidden: '8'}.freeze

  def self.colorize(text, colour = :default, bg_colour = :default, **options)
    if ! $stdout.tty?
      return text
    else
      colour_code    = COLOURS[colour]
      bg_colour_code = BG_COLOURS[bg_colour]
      font_options   = options.select { |k, v| v && FONT_OPTIONS.key?(k) }.keys
      font_options   = font_options.map { |e| FONT_OPTIONS[e] }.join(';').squeeze
      return "\e[#{bg_colour_code};#{font_options};#{colour_code}m#{text}\e[0m".squeeze(';')
    end
  end
end

def column_width(list, colname)
  list.map { |row| (row[colname] == nil) ? 0 : row[colname].to_s.length }.max
end

def render_number(row, widths, field_name, width_key, color)
  field_value = row[field_name]
  if field_value == nil
    field_value = ''
  end
  Colorizator.colorize(field_value.to_s.rjust(widths[width_key]), color, :default, bold: (field_value != 0)) + Colorizator.colorize(' | ', :black)
end

def render_string(row, widths, field_name, width_key, just)
  if width_key == nil
    padding = widths.reject { |k, _| [:fix, :tip].include?(k) }.values.sum + 15
  else
    padding = widths[width_key]
  end
  if just == :rjust
    (row[field_name] || '').rjust(padding) + Colorizator.colorize(' | ', :black)
  else
    (row[field_name] || '').ljust(padding) + Colorizator.colorize(' | ', :black)
  end
end

def render_tip(row, widths, field_name, width_key)
  tip_value = row[field_name] || ''
  padded = tip_value.ljust(widths[width_key])
  # Dim the SHA to match separator styling while keeping author readable.
  colored = padded.sub(/\A([0-9a-f]{7,40})/) { |sha| Colorizator.colorize(sha, :black) }
  colored + Colorizator.colorize(' | ', :black)
end

def print_row(row, widths)
  r = ''
  r += (row[:fix] || '').ljust(widths[:fix])
  if (row[:fix] || '').length > widths[:fix]
    r += "\n" + ''.ljust(widths[:fix])
  end
  r += Colorizator.colorize(' # ', :black)
  if row[:type] != :footer
    r += render_string(row, widths, :branch, :branch, :ljust)
    r += render_string(row, widths, :age, :age, :rjust)
    r += render_number(row, widths, :aheadOrigin, :aheadOrigin, :green)
    r += render_number(row, widths, :behindOrigin, :behindOrigin, :red)
    r += render_number(row, widths, :aheadSync, :aheadSync, :green)
    r += render_number(row, widths, :behindSync, :behindSync, :red)
    r += render_tip(row, widths, :tip, :tip)
  else
    r += render_string(row, widths, :branch, nil, :rjust)
  end
  puts r
end

def print_type(json, header, type, widths)
  if json.find_all { |row| row[:type] == type }.size > 0
    puts ''
    if header != ''
      h = ''.ljust(widths[:fix]) + Colorizator.colorize(' # ', :black)
      h += Colorizator.colorize(header, :white, :default, bold: true)
      puts h
    end
    json.find_all { |row| row[:type] == type }
        .each { |row| print_row(row, widths) }
  end
end

def find_sync_branch
  remotes = `git remote`.split
  remote = remotes.include?('upstream') ? 'upstream' : 'origin'

  # Try to find the primary branch without networking
  head_ref = `git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null`.strip
  if !head_ref.empty?
      primary_branch = head_ref.split('/').last
  else
      if `git rev-parse --verify origin/main 2>/dev/null`.strip != ""
        primary_branch = "main"
      elsif `git rev-parse --verify origin/master 2>/dev/null`.strip != ""
        primary_branch = "master"
      else
        # Fallback to network call if absolutely necessary
        primary_branch = `git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 | xargs echo -n`
      end
  end
  "#{remote}/#{primary_branch}"
end

SYNC_BRANCH = find_sync_branch
SYNC_REMOTE = SYNC_BRANCH.split('/')[0]
SYNC_BRANCH_ONLY = SYNC_BRANCH.split('/')[1]

# Fetch all refs, ages, ahead-behind vs sync branch, and tip metadata in one git call
refs_output = `git for-each-ref --format="%(refname)%09%(committerdate:relative)%09%(ahead-behind:#{SYNC_BRANCH})%09%(objectname:short=8)%09%(authorname)" refs/heads refs/remotes`
all_refs = {}
all_ref_tips = {}
sync_ahead_behind = {}
local_branches = []
remote_branches = []

refs_output.split("\n").each do |line|
  parts = line.split("\t", 5)
  full_ref = parts[0]
  date = parts[1]
  ahead_behind = parts[2]
  short_sha = parts[3]
  author = parts[4]
  age = date.split(',').first.strip
  ahead, behind = ahead_behind.split(' ').map(&:to_i)

  if full_ref.start_with?('refs/heads/')
    short_name = full_ref.sub('refs/heads/', '')
    local_branches << short_name
    all_refs[short_name] = age
    all_ref_tips[short_name] = [short_sha, author].compact.join(' ').strip
    sync_ahead_behind[short_name] = { ahead: ahead, behind: behind }
  elsif full_ref.start_with?('refs/remotes/origin/') && !full_ref.end_with?('/HEAD')
    short_name = full_ref.sub('refs/remotes/origin/', '')
    remote_branches << short_name
    all_refs["origin/#{short_name}"] = age
    all_ref_tips["origin/#{short_name}"] = [short_sha, author].compact.join(' ').strip
    sync_ahead_behind["origin/#{short_name}"] = { ahead: ahead, behind: behind }
  end
end

tracked_branches     = local_branches & remote_branches
local_only_branches  = local_branches - tracked_branches
remote_only_branches = remote_branches - tracked_branches
excluded_branches    = ['master', 'main', 'develop', 'gh-pages', SYNC_BRANCH_ONLY]

data = [
    {
        :type        => :header,
        :fix         => '# Cleanup Command',
        :branch      => 'Branch', :age => 'Age',
        :aheadOrigin => 'orgn+', :behindOrigin => 'orgn-',
        :aheadSync   => 'trgt+', :behindSync => 'trgt-',
        :tip         => 'tip',
    }
]

local_only_branches.each do |name|
  ab = sync_ahead_behind[name]
  ret_val = {
      type:       :local,
      branch:     name,
      age:        all_refs[name] || '',
      aheadSync:  ab[:ahead],
      behindSync: ab[:behind],
      tip:        all_ref_tips[name] || '',
  }
  if ret_val[:aheadSync] == 0 && !excluded_branches.include?(name)
    ret_val[:fix] = "git branch -D #{name}"
  end
  data.append ret_val
end

remote_only_branches.each do |name|
  ab = sync_ahead_behind["origin/#{name}"]
  ret_val = {
      type:       :remote,
      branch:     name,
      age:        all_refs["origin/#{name}"] || '',
      aheadSync:  ab[:ahead],
      behindSync: ab[:behind],
      tip:        all_ref_tips["origin/#{name}"] || '',
  }
  if ret_val[:aheadSync] == 0 && !excluded_branches.include?(name)
    ret_val[:fix] = "git push origin :#{name}"
  end
  data.append ret_val
end

# For tracked branches, get origin ahead-behind in parallel threads
origin_ahead_behind = {}
threads = tracked_branches.map do |name|
  Thread.new(name) do |n|
    result = `git rev-list --left-right --count #{n}...origin/#{n} 2>/dev/null`.strip
    ahead, behind = result.split("\t").map(&:to_i)
    [n, ahead, behind]
  end
end
threads.each do |t|
  name, ahead, behind = t.value
  origin_ahead_behind[name] = { ahead: ahead, behind: behind }
end

tracked_branches.each do |name|
  ab_sync = sync_ahead_behind[name]
  ab_origin = origin_ahead_behind[name]
  ret_val = {
      type:         :tracked,
      branch:       name,
      age:          all_refs[name] || '',
      aheadSync:    ab_sync[:ahead],
      behindSync:   ab_sync[:behind],
      aheadOrigin:  ab_origin[:ahead],
      behindOrigin: ab_origin[:behind],
      tip:          all_ref_tips[name] || '',
  }
  if ret_val[:aheadSync] == 0 && !excluded_branches.include?(name)
    ret_val[:fix] = "git branch -D #{name}; git push origin :#{name}"
  end
  data.append ret_val
end

widths = {
    branch:       column_width(data, :branch),
    age:          column_width(data, :age),
    aheadOrigin:  column_width(data, :aheadOrigin),
    behindOrigin: column_width(data, :behindOrigin),
    aheadSync:    column_width(data, :aheadSync),
    behindSync:   column_width(data, :behindSync),
    tip:          column_width(data, :tip),
    fix:          70,
}

data.append ({
  :type => :footer,
  :branch => "TARGET: #{SYNC_BRANCH}",
})
print_type(data, '', :header, widths)
print_type(data, 'Local', :local, widths)
print_type(data, 'Remote', :remote, widths)
print_type(data, 'Tracked', :tracked, widths)
print_type(data, '', :footer, widths)
